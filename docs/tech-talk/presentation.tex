\documentclass[13pt]{beamer}

\usetheme{CambridgeUS}
\usepackage{nth}
\usepackage{pgfplots}
\usepackage{csvsimple}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{csquotes}

\usepackage[backend=biber,style=ieee]{biblatex}
% \addbibresource{references.bib}

\title{Practical Analysis of Hybrid Sorting Algorithms}
\subtitle{Engineering a Faster Standard Sorting Implementation}
\author{Joshua Arulsamy}
\date{May 18, 2023}

\makeatletter
\defbeamertemplate*{footline}{Dan P theme}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor\expandafter\beamer@ifempty\expandafter{\beamer@shortinstitute}{}{~~(\insertshortinstitute)}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.4\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
\insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother

\begin{document}

% Remove logo
\logo{}
\nocite{*}

\begin{frame}
	\titlepage
\end{frame}

\section{}
\subsection{}
\begin{frame}{Outline}
	\tableofcontents
\end{frame}

\section{Introduction}
\subsection{About Me}
\begin{frame}{About Me}
	\begin{itemize}
		\item TODO
	\end{itemize}
\end{frame}

\section{Motivation}
\subsection{What's the Deal with Sorting?}
\begin{frame}{What's the Deal with Sorting?}
	\begin{itemize}
		\item Arguably one of the most researched CS problems.
		\item Many common tasks require sorting somewhere as a step.
		\item Pretty much every programming class covers sorting.
		\item Every programmer must implement sort.
		\item We need fast, standard, type-generic sorting functions in C.
	\end{itemize}
\end{frame}

\subsection{The Existing Solution}
\begin{frame}[c]{The Existing Solution}
	\begin{center}
		\begin{minipage}{0.8\textwidth}
			\inputminted{c}{include.c}
		\end{minipage}

		\pause
		\vspace{0.3cm}
		\begin{displayquote}
			``The \texttt{qsort()} function sorts an array with \texttt{nmemb}
			elements of \texttt{size} size. The \texttt{base} argument points to the
			start of the array.

			The contents of the array are sorted in ascending order according to a
			comparison function pointed to by \texttt{cmp}, which is called with two
			arguments that point to the objects being compared.''
		\end{displayquote}

		\pause
		\textit{Usually} \texttt{qsort()} is implemented using quicksort internally.
	\end{center}
\end{frame}

\section{Vision}
\subsection{What Did I Plan To Do?}
\begin{frame}{Making a Faster Version of \texttt{qsort()}}
	\begin{enumerate}
		\item\pause Find some fast implementation of quicksort.
		\item\pause Combine it with insertion sort or some other secondary
		algorithms.
		\item\pause Determine a suitable threshold value to switch to insertion sort
		internally through copious amounts of testing.
		\item\pause Handle a copious amount of edge-cases.
		\item\pause Propose this new implementation to the glibc community.
	\end{enumerate}
\end{frame}

\section{Analyzing Existing Implementations}
\subsection{Quicksort}
\begin{frame}{Why is Quicksort So Popular?}
	\begin{itemize}
		\item\pause Runs in-place, requires only a constant amount of extra memory.
		\item\pause Fundamentally easy to code and analyze.
		\item\pause Can optimize for corner cases relatively easily.
		\item\pause Fast on average.
		\item\pause Little work on (nearly) sorted data.
		\item\pause Cache friendly.
		\item\pause Maintains a good balance between comparisons and swaps.
	\end{itemize}
\end{frame}

\begin{frame}{Challenges}
	\begin{itemize}
		\item\pause Quicksort's performance is primarily dictated by good
		pivot selection.
		\item\pause Poor pivot selection can adversely affect performance.
		\item\pause Worst case $O(n^{2})$ runtime.
		\item\pause Somewhat limited in performance compared to other algorithms
		which use more memory.
	\end{itemize}
\end{frame}

\begin{frame}{When \texttt{qsort} isn't Quicksort}
	\begin{itemize}
		\item\pause Although the name implies it, \texttt{qsort()} doesn't
		\textit{have} to use Quicksort internally.
		\item\pause In fact, the C standard imposes no restriction on what
		algorithms are used internally at all.
		\item\pause Many standard libraries, such as GNU's libc, don't use quicksort
		all the time anymore.
	\end{itemize}
\end{frame}

% \subsection{Commonly Used Algorithms}
% \begin{frame}{Quicksort}
% 	\begin{itemize}
% 		\item Fundamentally easy to implement and analyze.
% 		\item Fast in the average case.
% 		\item Performs well with (almost) sorted data.
% 		\item Generally cache friendly.
% 		\item Good balance between comparisons and swaps.
% 	\end{itemize}
% \end{frame}

% \begin{frame}{Mergesort}
% 	TODO
% \end{frame}

% \begin{frame}{Insertion Sort}
% 	TODO
% \end{frame}

% \section{Exploring Existing Implementations}
% \subsection{GNU libc}
% \begin{frame}{GNU libc}
% 	TODO
% \end{frame}

% \begin{frame}{Wait, \texttt{qsort} doesn't use quicksort?}
% 	TODO
% \end{frame}

\end{document}
