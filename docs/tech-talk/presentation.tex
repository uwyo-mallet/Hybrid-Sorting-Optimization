\documentclass[13pt]{beamer}

\usetheme{CambridgeUS}
\usepackage{nth}
\usepackage{pgfplots}
\usepackage{csvsimple}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{csquotes}

\usepackage[backend=biber,style=ieee]{biblatex}
% \addbibresource{references.bib}

\title{Practical Analysis of Hybrid Sorting Algorithms}
\subtitle{Engineering a Faster Standard Sorting Implementation}
\author{Joshua Arulsamy}
\date{May 18, 2023}

\makeatletter
\defbeamertemplate*{footline}{Dan P theme}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor\expandafter\beamer@ifempty\expandafter{\beamer@shortinstitute}{}{~~(\insertshortinstitute)}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.4\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
\insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother

\begin{document}

% Remove logo
\logo{}
\nocite{*}

\begin{frame}
	\titlepage
\end{frame}

\section{}
\subsection{}
\begin{frame}{Outline}
	\tableofcontents
\end{frame}

\section{Introduction}
\subsection{About Me}
\begin{frame}{About Me}
	\begin{itemize}
		\item TODO
	\end{itemize}
\end{frame}

\section{Motivation}
\subsection{What's the Deal with Sorting?}
\begin{frame}{What's the Deal with Sorting?}
	\pause
	\begin{itemize}[<+->]
		\item Arguably one of the most researched CS problems.
		\item Many common tasks require sorting somewhere as a step.
		\item Pretty much every programming class covers sorting.
		\item Every programmer must implement sort.
		\item We need fast, standard, type-generic sorting functions in C.
	\end{itemize}
\end{frame}

\subsection{The Existing Solution}
\begin{frame}[c]{The Existing Solution}
	\begin{center}
		\begin{minipage}{0.8\textwidth}
			\inputminted{c}{include.c}
		\end{minipage}

		\pause
		\vspace{0.3cm}
		\begin{displayquote}
			``The \texttt{qsort()} function sorts an array with \texttt{nmemb}
			elements of \texttt{size} size. The \texttt{base} argument points to the
			start of the array.

			The contents of the array are sorted in ascending order according to a
			comparison function pointed to by \texttt{cmp}, which is called with two
			arguments that point to the objects being compared.''
		\end{displayquote}

		\pause
		\textit{Usually} \texttt{qsort()} is implemented using quicksort internally.
	\end{center}
\end{frame}

\section{Vision}
\subsection{What Did I Plan To Do?}
\begin{frame}{Engineering a Faster Version of \texttt{qsort()}}
	\pause
	\begin{enumerate}[<+->]
		\item Find some fast implementation of quicksort.
		\item Combine it with insertion sort or some other secondary
		      algorithms.
		\item Determine a suitable threshold value to switch to insertion sort
		      internally through copious amounts of testing.
		\item Propose this new implementation to the glibc community.
	\end{enumerate}

	\pause
	\vspace{0.3cm}
	By using a simple algorithm for small arrays, we can avoid some of the
	overhead of more complicated algorithms.
\end{frame}
\begin{frame}{Engineering a Faster Version of \texttt{qsort()}}
	\begin{enumerate}
		\item Find some fast implementation of quicksort.
		\item Combine it with insertion sort or some other secondary
		      algorithms.
		\item \color{red}Determine a suitable threshold value to switch to insertion sort
		      internally through copious amounts of testing.\normalcolor
		\item Propose this new implementation to the glibc community.
	\end{enumerate}

	\vspace{0.3cm}
	By using a simple algorithm for small arrays, we can avoid some of the
	overhead of more complicated algorithms.
\end{frame}


\section{Analyzing Existing Implementations}
\subsection{Quicksort}
\begin{frame}{Why is Quicksort So Popular?}
	\pause
	\begin{itemize}[<+->]
		\item Runs in-place, requires only a constant amount of extra memory.
		\item Fundamentally easy to code and analyze.
		\item Can optimize for corner cases relatively easily.
		\item Fast on average.
		\item Little work on (nearly) sorted data.
		\item Cache friendly.
		\item Maintains a good balance between comparisons and swaps.
	\end{itemize}
\end{frame}

\begin{frame}{Challenges}
	\pause
	\begin{itemize}[<+->]
		\item Quicksort's performance is primarily dictated by good
		      pivot selection.
		\item Poor pivot selection can adversely affect performance.
		\item Worst case $O(n^{2})$ runtime.
		\item Somewhat limited in performance compared to other algorithms
		      which use more memory.
	\end{itemize}
\end{frame}

\subsection{Glibc}
\begin{frame}{When \texttt{qsort()} isn't Quicksort}
	\begin{itemize}[<+->]
		\item Although the name implies it, \texttt{qsort()} doesn't
		      \textit{have} to use Quicksort internally.
		\item In fact, the C standard imposes no restriction on what
		      algorithms are used internally at all.
		\item Many standard libraries, such as glibc, don't use quicksort
		      all the time anymore.
		\item So, what does glibc use?
	\end{itemize}
\end{frame}

\begin{frame}{Wait, \texttt{qsort()} is Mergesort?}
	\pause
	\begin{itemize}[<+->]
		\item The current \texttt{qsort()} implementation in glibc is recursive
		      Mergesort, which automatically falls-back to quicksort if memory is
		      limited.
		\item We can leverage memory availability for better performance.
		\item No real downside, we can still operate in memory constrained environments.
	\end{itemize}
\end{frame}

\subsection{Mergesort}
\begin{frame}{Why use mergesort over quicksort?}
	\pause
	\begin{itemize}[<+->]
		\item Generally easy to implement and reason about.
		\item Worst case $O(n\log{n})$
		\item Uses approximately 30\% less comparisons than quicksort.
		\item Parallelizes well.
		\item Stable.
	\end{itemize}
\end{frame}

\begin{frame}{So how can we make it faster?}
  TODO
\end{frame}

\end{document}
