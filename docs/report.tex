%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letter, 12pt, conference]{ieeeconf}

\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% Reduce space between figures and text
\setlength{\textfloatsep}{5pt}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{nth}
\usepackage{pgfplots}
\usepackage{titlesec}
\usepackage[backend=biber,style=ieee]{biblatex}
\usepackage{multirow}

\newcommand{\todo}{\colorbox{red}{TODO}}
\newcommand{\todocite}{\colorbox{red}{TODO\_CITE}}

\addbibresource{references.bib}
\renewcommand*{\bibfont}{\small}

\title{\LARGE \bf Practical Analysis of Hybrid Sorting Algorithms}
\author{Joshua Arulsamy}

\author{\parbox{3 in}{
\centering
Joshua Arulsamy\\
University of Wyoming\\
{\tt\small jarulsam@uwyo.edu}}}

\begin{document}

\maketitle
\thispagestyle{plain}
\pagestyle{plain}
\nocite{*}

% Reduce space between figures and text
\setlength{\textfloatsep}{2pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

	\todo

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}

Most applications require data to be arranged in a certain order. The procedure
of reordering data according to some comparator is called sorting. Sorting can
be found in nearly every computer system today. From databases to payment
processing systems, data is constantly being sorted. The near omnipresent need
for performant sorting implementations has resulted in all major programming
languages including a generic sorting function within their standard libraries.
These standard implementations can use a variety of algorithms internally, such
as Quicksort, Mergesort, and many others (\todocite), however, rarely does a
single algorithm perform exceptionally well. Often, these algorithms are paired
with one or more other sorting algorithms to offer sizeable performance
benefits. These hybrid algorithms include some tuneable parameters, such as when
to switch from one sorting algorithm to another. While these hybridized
algorithms have varying space and time complexities, their actual performance in
real-world scenarios is rarely formally examined, and the values for these
various parameters are often chosen arbitrarily by the developer. This paper
analyzes a wide variety of sorting algorithm implementations across varying
system architectures to determine optimal parameter configurations for hybrid
sorting algorithms. This paper also proposes a new performant standard sorting
implementation for GNU's C standard library.

\section{BACKGROUND}

Substantial effort has been spent on analysis of sorting algorithms. Typically,
two major characteristics are considered when studying sorting algorithms from a
purely theoretical standpoint, space and time complexity. Existing analysis of
popular sorting algorithms, such as Quicksort and Mergesort, place substantial
emphasis on their excellent asymptotic complexity in the average
case(\todocite). However, asymptotic complexity alone does not describe the
practical performance of an algorithm. While Mergesort may have a better
asymptotic time complexity in the worst case than insertion sort (Table
\ref{fig:time_complexity_table}), for small inputs, insertion sort typically
outperforms Mergesort.

\begin{table}[h]
	\centering
	\resizebox{\columnwidth}{!}{
		\begin{tabular}{|c|lll|}
			\hline
			\textbf{Algorithm} & \multicolumn{3}{c|}{\textbf{Time Complexity}}                                                                                 \\ \hline
			                   & \multicolumn{1}{l|}{\textbf{Best}}            & \multicolumn{1}{l|}{\textbf{Average}}         & \textbf{Worst}                \\ \hline
			Quicksort          & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log{(n)})$}     & $\mathcal{O}(n^{2})$          \\ \hline
			Mergesort          & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log{(n)})$}     & $\mathcal{O}(n\log{(n)})$     \\ \hline
			Heapsort           & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log{(n)})$}     & $\mathcal{O}(n\log{(n)})$     \\ \hline
			Bubble Sort        & \multicolumn{1}{l|}{$\Omega(n)$}              & \multicolumn{1}{l|}{$\Theta(n^{2})$}          & $\mathcal{O}(n\log{(n)})$     \\ \hline
			Insertion Sort     & \multicolumn{1}{l|}{$\Omega(n)$}              & \multicolumn{1}{l|}{$\Theta(n^{2})$}          & $\mathcal{O}(n^{2})$          \\ \hline
			Tree Sort          & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log(n))$}       & $\mathcal{O}(n^{2})$          \\ \hline
			Shell Sort         & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n(\log(n))^{2})$} & $\mathcal{O}(n(\log(n))^{2})$ \\ \hline
		\end{tabular}}
	\caption{Sorting algorithm asymptotic time complexities \todocite}
	\label{fig:time_complexity_table}
\end{table}

Most of these algorithms have not been sufficiently benchmarked in real world
scenarios to determine a true optimal implementation for most scenarios. By
evaluating specific scenarios where an algorithm performs well may lead to
better sorting function implementations by combining several algorithms or
excluding algorithms in specific situations. Since sorting is used so
ubiquitously, even incremental improvements to standard library sorting
implementations can broadly influence the performance of many different
applications. This marks an area in obvious need of further investigation.

\section{EXPERIMENTAL SETUP}

\todo

\section{RESULTS}

\todo

\section{CONCLUSION}

\todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This command serves to balance the column lengths on the last page of the
% document manually. It shortens the textheight of the last page by a suitable
% amount. This command does not take effect until the next page so it should
% come on the page before the last. Make sure that you do not shorten the
% textheight too much.
% \addtolength{\textheight}{-12cm}

% \titleformat*{\section}{\fontsize{12pt}{14pt}\MakeUppercase\selectfont}
\printbibliography
\end{document}
