%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letter, 12pt, conference]{ieeeconf}

\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% Reduce space between figures and text
\setlength{\textfloatsep}{5pt}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{nth}
\usepackage{pgfplots}
\usepackage{titlesec}
\usepackage[backend=biber,style=ieee]{biblatex}
\usepackage{multirow}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\newcommand{\todo}{\colorbox{red}{TODO}}
\newcommand{\todocite}{\colorbox{red}{TODO\_CITE}}

\addbibresource{references.bib}
\renewcommand*{\bibfont}{\small}

\title{\LARGE \bf Practical Analysis of Hybrid Sorting Algorithms}
\author{Joshua Arulsamy}

\author{\parbox{3 in}{
\centering
Joshua Arulsamy\\
University of Wyoming\\
{\tt\small jarulsam@uwyo.edu}}}

\begin{document}

\maketitle
\thispagestyle{plain}
\pagestyle{plain}
\nocite{*}

% Reduce space between figures and text
\setlength{\textfloatsep}{2pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

	\todo

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{INTRODUCTION}

Most applications require data to be arranged in a certain order. The procedure
of reordering data according to some comparator is called sorting. Sorting can
be found in nearly every computer system today. From databases to payment
processing systems, data is constantly being sorted. The near omnipresent need
for performant sorting implementations has resulted in all major programming
languages including a generic sorting function within their standard libraries.
These standard implementations can use a variety of algorithms internally, such
as Quicksort, Mergesort, and many others (\todocite), however, rarely does a
single algorithm perform exceptionally well. Often, these algorithms are paired
with one or more other sorting algorithms to offer sizeable performance
benefits. These hybrid algorithms include some tuneable parameters, such as when
to switch from one sorting algorithm to another. While these hybridized
algorithms have varying space and time complexities, their actual performance in
real-world scenarios is rarely formally examined, and the values for these
various parameters are often chosen arbitrarily by the developer. This paper
analyzes a wide variety of sorting algorithm implementations across varying
system architectures to determine optimal parameter configurations for hybrid
sorting algorithms. This paper also proposes a new performant standard sorting
implementation for GNU's C standard library.

\section{BACKGROUND}

Substantial effort has been spent on analysis of sorting algorithms. Typically,
two major characteristics are considered when studying sorting algorithms from a
purely theoretical standpoint, space and time complexity. Existing analysis of
popular sorting algorithms, such as Quicksort and Mergesort, place substantial
emphasis on their excellent asymptotic complexity in the average
case(\todocite). However, asymptotic complexity alone does not describe the
practical performance of an algorithm. While Mergesort may have a better
asymptotic time complexity in the worst case than insertion sort (Table
\ref{fig:time_complexity_table}), for small inputs, insertion sort typically
outperforms Mergesort.

\begin{table}[h]
	\centering
	\resizebox{\columnwidth}{!}{
		\begin{tabular}{|c|lll|}
			\hline
			\textbf{Algorithm} & \multicolumn{3}{c|}{\textbf{Time Complexity}}                                                                                 \\ \hline
			                   & \multicolumn{1}{l|}{\textbf{Best}}            & \multicolumn{1}{l|}{\textbf{Average}}         & \textbf{Worst}                \\ \hline
			Quicksort          & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log{(n)})$}     & $\mathcal{O}(n^{2})$          \\ \hline
			Mergesort          & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log{(n)})$}     & $\mathcal{O}(n\log{(n)})$     \\ \hline
			Heapsort           & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log{(n)})$}     & $\mathcal{O}(n\log{(n)})$     \\ \hline
			Bubble Sort        & \multicolumn{1}{l|}{$\Omega(n)$}              & \multicolumn{1}{l|}{$\Theta(n^{2})$}          & $\mathcal{O}(n\log{(n)})$     \\ \hline
			Insertion Sort     & \multicolumn{1}{l|}{$\Omega(n)$}              & \multicolumn{1}{l|}{$\Theta(n^{2})$}          & $\mathcal{O}(n^{2})$          \\ \hline
			Tree Sort          & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n\log(n))$}       & $\mathcal{O}(n^{2})$          \\ \hline
			Shell Sort         & \multicolumn{1}{l|}{$\Omega(n\log{(n)})$}     & \multicolumn{1}{l|}{$\Theta(n(\log(n))^{2})$} & $\mathcal{O}(n(\log(n))^{2})$ \\ \hline
		\end{tabular}}
	\caption{Sorting algorithm asymptotic time complexities \todocite}
	\label{fig:time_complexity_table}
\end{table}

Most of these algorithms have not been sufficiently benchmarked in real world
scenarios to determine a true optimal implementation for most scenarios.
Evaluating specific scenarios where an algorithm performs well may lead to
better sorting function implementations by combining several algorithms or
excluding algorithms in specific situations. Since sorting is used so
ubiquitously, even incremental improvements to standard library sorting
implementations can broadly influence the performance of many different
applications. This marks an area in obvious need of further investigation.

\todo Describe that such an analysis does not really exist.

\section{EXPERIMENTAL SETUP}

A small subset of algorithms were chosen for evaluation. Primarily, algorithms
utilized within standard library implementations are of particular interest,
since they are typically highly performant in the general case. Other
complementary algorithms which perform exceptionally well in specific scenarios
were also evaluated. Since this analysis is focused on analyzing and improving
existing implementations, general purpose sorting function were taken from
various standard libraries, such as GNU's libc and musl libc \todocite. It is a
priority to maintain the applicability of any optimizations discovered as a
result of this evaluation to existing standard libraries, so any non-comparison
based sorting algorithm, such as Radix sort or Bucket sort were excluded.

% Any optimization gained as a result of this evaluation

\subsection{General Purpose Algorithms}

Of the well known sorting algorithms, two are used most often for general
sorting tasks, Quicksort and Mergesort. Quicksort has been a staple algorithm
for decades. It is well known to be easy to implement and works well for a
variety of input data. Quicksort also requires a constant amount of extra memory
independent of the size of the input, making it an obvious choice in resource
constrained environments. However, it is important to acknowledge the
significant pitfalls of most Quicksort implementations.

\subsection{Specialized Algorithms}

\subsection{Proposed Algorithm}

General purpose sorting algorithms are typically difficult to optimize
uniformly. Since these implementations very often live in standard libraries,
use-case specific optimizations are not feasible. During runtime, quick,
low-overhead analysis about the input can reveal opportunities for
input-specific optimizations. However, for small input sizes, the overhead from
such an analysis often contributes more to the overall runtime, than even
utilizing an algorithm ill-suited for that specific input. This motivates
placing significant importance on the input size itself. Comparing the input
size against pre-defined threshold values is cheap and can help pick an
algorithm.

\begin{algorithm}
	\caption{Network Sort}
	\label{alg:network_sort}
	\begin{algorithmic}
		\Procedure{sort2}{a, b}
		\State $t \gets min(a, b)$
		\State $b \gets max(a, b)$
		\State $a \gets t$
		\EndProcedure

		\Procedure{sort3}{a, b, c}
		\State sort2(a, b)
		\State sort2(b, c)
		\State sort2(a, b)
		\EndProcedure

		\Procedure{sort4}{a, b, c, d}
		\State sort2(a, b)
		\State sort2(b, c)
		\State sort2(a, c)
		\State sort2(b, d)
		\State sort2(b, c)
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Insertion Sort}
	\label{alg:insertion_sort}
	\begin{algorithmic}
		\Procedure{ins\_sort}{a, n}
		\If {$n == 2$}
		\State sort2(a[0], a[1])
		\ElsIf {$n == 3$}
		\State sort3(a[0], a[1], a[2])
		\ElsIf {$n == 4$}
		\State sort4(a[0], a[1], a[2], a[3])
		\Endif

		\EndProcedure
	\end{algorithmic}
\end{algorithm}


\section{RESULTS}

\todo

\section{CONCLUSION}

\todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This command serves to balance the column lengths on the last page of the
% document manually. It shortens the textheight of the last page by a suitable
% amount. This command does not take effect until the next page so it should
% come on the page before the last. Make sure that you do not shorten the
% textheight too much.
% \addtolength{\textheight}{-12cm}

% \titleformat*{\section}{\fontsize{12pt}{14pt}\MakeUppercase\selectfont}
\printbibliography
\end{document}
